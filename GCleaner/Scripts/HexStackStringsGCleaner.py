from binaryninja import *

def traverse_all_basic_blocks(bv):
    flag_decrypt = 0
    flag_size = 0
    encrypted_string = []
    decrypted_string = ""
    # Iterate through all functions in the binary view
    for func in bv.functions:
        # Print the name of the function
        #print("Function:", func.name)
        for block in func.low_level_il:
            for instr in block:
                if instr.operation == LowLevelILOperation.LLIL_SET_REG:
                    var_const = instr.src
                    #print("Constant:",var_const)
                    #print("Constant type:",type(var_const))
                    #print("Constant size:",var_const.size)
                    if var_const.size == 1 and type(var_const) == LowLevelILConst:
                        #print("Appending to array",var_const) 
                        encrypted_string.append(var_const)
                elif instr.operation == LowLevelILOperation.LLIL_CALL:
                    var_call = ""
                    var_call = str(instr.operands[0])
                    if var_call == "0x401c33":
                        #print("The block has a decryption call!")
                        #print("Hex String",encrypted_string)
                        address = hex(instr.address)
                        for value in encrypted_string:
                            #print("Printing values found",value)
                            #print(chr(int(value)))
                            decrypted_string += chr(int(value))
                        #print(address,":",decrypted_string)
                        address = int(address,base=16)                        
                        print("bv.set_comment_at(",address,",\"",decrypted_string,"\")")
                        #bv.set_comment_at(address,decrypted_string)
                        decrypted_string = ""
                        encrypted_string = []


# Open the binary file
bv = binaryninja.load(PathToSample)

# Get the text section
text_section = bv.sections[".text"]

# Print the start address and size of the text section
print("Text Section:")
print("Start Address:", hex(text_section.start))
print("Size:", text_section.entry_size)

# Print all functions in the binary
print("\nAll Functions:")
traverse_all_basic_blocks(bv)
